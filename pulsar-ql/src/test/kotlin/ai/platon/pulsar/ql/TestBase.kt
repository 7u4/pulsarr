package ai.platon.pulsar.ql

import ai.platon.pulsar.common.AppFiles
import ai.platon.pulsar.common.AppPaths
import ai.platon.pulsar.common.DateTimes
import ai.platon.pulsar.common.Strings
import ai.platon.pulsar.common.sql.ResultSetFormatter
import ai.platon.pulsar.context.PulsarContexts
import ai.platon.pulsar.ql.h2.H2Db
import ai.platon.pulsar.ql.h2.H2DbConfig
import org.apache.commons.lang3.RandomStringUtils
import org.h2.store.fs.FileUtils
import org.h2.tools.DeleteDbFiles
import org.h2.tools.Server
import org.junit.AfterClass
import org.junit.BeforeClass
import org.slf4j.LoggerFactory
import java.nio.file.Files
import java.sql.Connection
import java.sql.ResultSet
import java.sql.SQLException
import java.time.Instant
import java.util.concurrent.atomic.AtomicInteger
import kotlin.test.assertEquals

/**
 * The base class for all tests
 */
abstract class TestBase {

    companion object {
        init {
            SQLContexts.activate()
        }

        val log = LoggerFactory.getLogger(TestBase::class.java)

        val history = mutableListOf<String>()
        val startTime = Instant.now()

        val testDir get() = AppPaths.TEST_DIR.resolve(RandomStringUtils.randomAlphabetic(5))
        val embedDB = H2Db(H2DbConfig(baseDir = testDir))
        val name: String = embedDB.generateTempDbName()

        val remoteDB = H2Db(H2DbConfig(baseDir = testDir, networked = true))

        var server: Server? = null

        @JvmStatic
        @BeforeClass
        fun setup() {
            try {
                initializeDatabase()
            } catch (e: Throwable) {
                println(Strings.stringifyException(e))
            }
        }

        @JvmStatic
        @AfterClass
        fun teardown() {
            history.add(0, "-- Time: $startTime")
            val sqls = history.joinToString("\n") { it }
            val ident = DateTimes.now("MMdd.HH")
            val path = AppPaths.get("history", "sql-history-$ident.sql")
            Files.createDirectories(path.parent)
            AppFiles.saveTo(sqls, path, deleteIfExists = true)

            destroyDatabase()
        }

        /**
         * This method is called before a complete set of tests is run. It deletes
         * old database files in the test directory and trace files. It also starts
         * a TCP server if the test uses remote connections.
         */
        private fun initializeDatabase() {
            log.info("Initializing database")

            val numTests = this::class.members.count {
                it.annotations.any { it is org.junit.Test } && it.annotations.none { it is org.junit.Ignore }
            }
            if (numTests > 0) {
                history.add("\n-- Generated by ${javaClass.simpleName}")
            }

            embedDB.deleteDb(name)
            FileUtils.deleteRecursive(embedDB.conf.baseDir.toString(), true)
            DeleteDbFiles.execute(embedDB.conf.baseDir.toString(), null, true)

            log.info("Database base dir: " + embedDB.conf.baseDir)

            val config = remoteDB.conf
            val args = if (config.ssl)
                mutableListOf("-tcpSSL", "-tcpPort", config.port.toString())
            else
                mutableListOf("-tcpPort", config.port.toString())

            args.add("-trace")

            server = Server.createTcpServer(*args.toTypedArray())
            try {
                server?.start()
                server?.let { println("H2 Server status: " + it.status) }
            } catch (e: SQLException) {
                e.printStackTrace()
            }
        }

        /**
         * Clean test environment
         */
        private fun destroyDatabase() {
            embedDB.deleteDb(name)
            FileUtils.deleteRecursive(embedDB.conf.baseDir.toString(), true)

            server?.stop()
            server?.let { println("[Destroy database] H2 Server status: " + it.status) }
            FileUtils.deleteRecursive(remoteDB.conf.baseDir.toString(), true)

            log.info("Database destroyed")
        }
    }

    fun execute(sql: String, printResult: Boolean = true, remote: Boolean = false) {
        embedDB.getConnection(name)
            .createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE)
            .use { stat ->
                val regex = "^(SELECT|CALL).+".toRegex()
                if (sql.toUpperCase().filter { it != '\n' }.trimIndent().matches(regex)) {
                    val rs = stat.executeQuery(sql)
                    if (printResult) {
                        println(ResultSetFormatter(rs, withHeader = true))
                    }
                } else {
                    val r = stat.execute(sql)
                    if (printResult) {
                        println(r)
                    }
                }
    //            SysProperties.serializeJavaObject = lastSerializeJavaObject
                history.add("${sql.trim { it.isWhitespace() }};")
            }
    }

    fun query(sql: String, printResult: Boolean = true, remote: Boolean = false): ResultSet {
        embedDB.getConnection(name)
            .createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE)
            .use { stat ->
                val rs = stat.executeQuery(sql)
                if (printResult) {
                    println(ResultSetFormatter(rs))
                }
                history.add("${sql.trim { it.isWhitespace() }};")
                return rs
            }
    }

    fun assertResultSetEquals(expected: String, sql: String) {
        assertEquals(expected, ResultSetFormatter(query(sql)).toString())
    }
}
